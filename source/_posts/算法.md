---
title: 一些算法
cover: /imgs/algorithm.png
swiper_index: 2  #置顶轮播图顺序，非负整数，数字越大越靠前
categories: # 分类
	- 算法  # 只能由一个
tags:
    - 算法
    - 学习
---
<meta name="referrer" content="no-referrer" />

# 排序算法
https://zhuanlan.zhihu.com/p/567134257
## 冒泡排序
它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

>1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 
>2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 
>3. 针对所有的元素重复以上的步骤，除了最后一个。 
>4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
```python
def BubbleSort(mylist:list):
    for z in range(len(mylist)):
        #最后的z个已经排好序，不需要再排序了
        for i in range(len(mylist) - z-1):
            if mylist[i] > mylist[i + 1]:
                mylist[i], mylist[i + 1] = mylist[i + 1], mylist[i]
    return mylist
```
复杂度是O(n\*n)

## 插入排序
---
>&emsp;&emsp;将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
&emsp;&emsp;从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

&emsp;&emsp;例如数组[1,3,2],最开始将[1]看成已经排序好的数组，对于下一个数字3，插入进来，变成[1,3]，再对于下一个数字2，再插入到合适的位置变成[1,2,3]
```python
def insertSort(mylist:list):
    for i in range(1,len(mylist)):
        currentIndex = i-1#描述待插入的数字，现在与前面已经排好序的哪个数字比较
        node_now = mylist[i]#待插入数字
        while currentIndex>=0:
            if mylist[currentIndex]<=node_now:
                break
            #如果这个比较的数字比待插入数字大，则调换两者位置
            #事实上，待插入数字永远再跟数组的前一个数字比较，直到找到小于等于他的数字，表达插入完成
            elif mylist[currentIndex]>node_now :
                mylist[currentIndex],mylist[currentIndex+1] = mylist[currentIndex+1],mylist[currentIndex]
                currentIndex-=1
    return mylist

```
## 快速排序
---
&emsp;&emsp;对于一个无序数组mylist，首先随便找到一个基准值basis，找到数组里比这个basis小的所有值组成mylist_smaller，再找到比basis大的所有值组成mylist_bigger，再对这两个数组继续快速排序形成递归，return **quicksort(mylist_smaller)+[basis]+quicksort(mylist_bigger)**
```python
def quicksort(mylist:list):
    if len(mylist)<2:
        return mylist
    else:
        basis=mylist[0]
        #由于基准值是列表第一个，那么在下面两个list的时候，要排除这个数字
        mylist_smaller=[i for i in mylist[1:] if i<=basis]
        mylist_bigger=[i for i in mylist[1:] if i>basis]
        return quicksort(mylist_smaller)+[basis]+quicksort(mylist_bigger)
```
算法复杂度是平均O(n*log(n))，最坏的情况(每次的基准值都是当前的最小值或者最大值)是O(n\*n)

## 合并排序
---

1. 分解：将待排序的数组或列表递归地分成两个子序列，直到每个子序列只有一个元素。这个过程通过不断地将序列一分为二，直到无法再分解为止。
2. 合并：将两个有序的子序列合并成一个有序序列。这个过程中，通过比较两个子序列的元素大小，按照从小到大的顺序将它们合并成一个有序序列。
3. 递归：递归地应用上述两个步骤，直到所有子序列都被合并成一个有序序列为止
例如
>以从小到大排列为例，设原数组 [8, 4, 5, 7, 1, 3, 6, 2]
拆分
第一次：[8, 4, 5, 7]  [1, 3, 6, 2]
第二次：[8, 4]  [5, 7]  [1, 3]  [6, 2]
第三次：[8] [4] [5] [7] [1] [3] [6] [2]
合并并排序
第一次：[4, 8]  [5, 7]  [1, 3]  [6, 2]
第二次：[4, 5, 7, 8]  [1, 2, 3, 6]
第三次：[1, 2, 3, 4, 5, 6, 7, 8]



```python
def mergesort(mylist:list):
    if len(mylist)<2:
        return mylist
    else:
        # 中间数字的索引
        mid = int(len(mylist)/2)
        return my_merge(mergesort(mylist[:mid]),mergesort(mylist[mid:]))
    
#合并两个list
def my_merge(list1,list2):
    result = []
    #定义list1和list2的指针
    left=0
    right=0
    while 1:
        #当list1和list2中都还有未排序的数组
        if left<len(list1) and right<len(list2):
            #比较当前的两个数字，将小的加入结果，并将指针向后移
            if list1[left] <= list2[right]:
                result.append(list1[left])
                left += 1
            else:
                result.append(list2[right])
                right += 1
        #如果list2已经结束了，而list1还有数字，之间加到结果后面
        elif left<len(list1):
            result.extend(list1[left:])
            return result
        # 如果list1已经结束了，而list2还有数字，之间加到结果后面
        elif right<len(list2):
            result.extend(list2[right:])
            return result
        else:
            return result
```
## 计数排序
&emsp;&emsp;计数排序是一个非基于比较的排序算法，它的优势在于在对一定范围内的整数排序时，它的复杂度为 **Ο(n+k)**，其中 k 是整数的范围，快于任何比较排序算法。计数排序是一种**牺牲空间换取时间**的做法。计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
&emsp;&emsp;对于待排序数组mylist,创建一个计数数组countList，其长度等于max_num-min_num+1，也就是其每一个数字代表mylist中的某个数字出现的次数。
&emsp;&emsp;例如，对于数组[1,2,1,5,4,2,2,4]，对应的计数数组为[2,3,0,2,1]，代表数字1出现了2次，2出现了3次，以此类推。
```python
def countSort(mylist:list):
    max_num = max(mylist)
    min_num = min(mylist)
    result = []
    #计数列表，第一个数字代表mylist里面最小数字出现的次数，以此类推
    countList = [0]*(max_num-min_num+1)
    for i in mylist:
        #找到i在计数数组的位置，并加一
        countList[i-min_num]+=1
    # 将计数数组展开成为排序后的数组
    for i in range(len(countList)):
        result.extend([i+min_num]*countList[i])
    return result

```
# 广度优先搜索
---
&emsp;&emsp;广度优先搜索是一种图搜索算法，它通过**逐层遍历**图的节点来查找目标节点。**该算法从起始节点开始，先访问起始节点，然后访问起始节点的所有邻居节点，接着再访问这些邻居节点的邻居节点**，以此类推，直到遍历完所有可达节点。为了实现逐层遍历，我们通常使用**队列**来保存待访问的节点。
&emsp;&emsp;下面通过一个例子配合代码介绍这个算法，值得注意的是，广度优先只能适合**有向无权图**。

![请添加图片描述](https://i-blog.csdnimg.cn/blog_migrate/089be313b0bc2a6f645a4f64fb844ebd.png)


&emsp;&emsp;主要的思路是：假设我们要找到G，先在检查队列中加入start的第一层邻居节点（B,C,D），在发现B不是之后，马上加入B的邻居节点E,H，于是我们的检查队列变为（C,D,E,H），然后再检查C，依次类推，直到找到G
&emsp;&emsp;**队列的特性保证了检查的顺序，也就是优先检查距离start近的节点**
&emsp;&emsp;首先以字典的形式建立上面的图：
```python
graph={}
graph['start']=['B','C','D']
graph['B']=['E','H']
graph['C']=['G','F']
graph['D']=['E']
graph['E']=[]
graph['F']=[]
graph['G']=[]
graph['H']=[]
{'start': ['B', 'C', 'D'], 'B': ['E', 'H'], 'C': ['G', 'F'], 'D': ['E'], 'E': [], 'F': [], 'G': [], 'H': []}
```
&emsp;&emsp;构建广度优先算法函数：
```python
def wide_search(graph,target):
    search_queue = deque()#搜索队列
    searched = []#已经搜索完成的点，避免重复加入，例如E点，即是B的邻居节点又是D的邻居节点
    distance_queue = deque()#距离队列，保存每个节点关于start的距离
    # 首先search_queue加入start的子节点，此处有三个子节点，那么distance_queue要加入三个1
    search_queue.extend(graph['start'])
    distance_queue.extend([1]*len(graph['start']))

    while search_queue:#如果搜索队列为空，那么所有点的搜索都完成了
        # 弹出队列最前面的点及其距离
        node_now = search_queue.popleft()
        distance = distance_queue.popleft()
        if node_now not in searched:#判断这个点有没有被检查过
            if node_now == target:
                return distance
            else:
                search_queue.extend(graph[node_now])#如果这个点不是我们要找的，将其子节点加入搜索队列
                distance_queue.extend([distance+1]*len(graph[node_now]))#其子节点的距离应该是当前节点的距离+1
                searched.append(node_now)
    return False
```
最开始的搜索队列及距离队列为：
```python
deque(['B', 'C', 'D'])
deque([1, 1, 1])
```
然后发现B不是我们要找的，将B的子节点加入，变为：
```python
deque(['C', 'D', 'E', 'H'])
deque([1, 1, 2, 2])
```
以此类推，值得注意的是，此处E虽然被加入了两次，但是并不会判断两次
```python
search_queue: deque(['D', 'E', 'H', 'G', 'F'])
distance_queue: deque([1, 2, 2, 2, 2])
search_queue: deque(['E', 'H', 'G', 'F', 'E'])
distance_queue: deque([2, 2, 2, 2, 2])
search_queue: deque(['H', 'G', 'F', 'E'])
distance_queue: deque([2, 2, 2, 2])
search_queue: deque(['G', 'F', 'E'])
distance_queue: deque([2, 2, 2])
```
搜索过程为：
```python
['B', 'C', 'D', 'E', 'H', 'G']
```
结果为：
```python
print(wide_search(graph,'G'))
2
```
#深度优先算法
&emsp;&emsp;与广度优先类似，其过程简要来说是对**每一个可能的分支路径深入到不能再深入为止**，而且每个节点只能访问一次。
&emsp;&emsp;其实只需要在广度优先算法中改一点就行了：
```python
def wide_search(graph,target):
    search_queue = deque()#搜索队列
    #已经搜索完成的点，避免重复加入，例如E点，即是B的邻居节点又是D的邻居节点
    searched = []
    distance_queue = deque()#距离队列，保存每个节点关于start的距离
    # 首先search_queue加入start的子节点，此处有三个子节点，那么distance_queue要加入三个1
    search_queue.extend(graph['start'])
    distance_queue.extend([1]*len(graph['start']))
    search_list=[]
    while search_queue:#如果搜索队列为空，那么所有点的搜索都完成了
        # print('search_queue:',search_queue)
        # print('distance_queue:',distance_queue)
        # 弹出队列最前面的点及其距离
        node_now = search_queue.popleft()
        distance = distance_queue.popleft()
        if node_now not in searched:#判断这个点有没有被检查过
            search_list.append(node_now)
            if node_now == target:
                print(search_list)
                return distance
            else:
                #深度优先改了这里：
                #如果这个点不是我们要找的，将其子节点加入搜索队列的前面
                search_queue.extendleft(graph[node_now])
                #其子节点的距离应该是当前节点的距离+1
                distance_queue.extendleft([distance+1]*len(graph[node_now]))
                searched.append(node_now)
    return False
```
&emsp;&emsp;也就是说在发现某个点不是需要的点后，马上将其子节点加入搜索队列的最前面。搜索路径为：
```python
['B', 'H', 'E', 'C', 'F', 'G']
```
# Dijkstra算法
---
&emsp;&emsp;狄克斯特拉算法是从一个顶点到其余各顶点的**最短路径算法**，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。
&emsp;&emsp;值得注意的是，Dijkstra算法只适合**有向无环图（DAG）**，且不适合有**负权边**的情况。
&emsp;&emsp;算法的大概步骤为：

>1. 找到“最便宜”的点
>2. 更新这个点的邻居点的开销 
>3. 重复这个过程,直到所有节点都进行了上述步骤
>4. 计算最短路径


&emsp;&emsp;下面通过一个例子配合代码介绍这个算法：

![请添加图片描述](https://i-blog.csdnimg.cn/blog_migrate/aba35592951c5c7ab40ae5298717f7d6.png)



&emsp;&emsp;首先使用字典的形式构造上述图的数据结构：
```python
graph={}
graph['start']={}
graph['start']['A']=5
graph['start']['B']=0

graph['A']={}
graph['A']['C']=15
graph['A']['D']=20

graph['B']={}
graph['B']['C']=30
graph['B']['D']=35

graph['C']={'end':20}
graph['D']={'end':10}

graph['end']={}

{'start': {'A': 5, 'B': 0}, 'A': {'C': 15, 'D': 20}, 'B': {'C': 30, 'D': 35}, 'C': {'end': 20}, 'D': {'end': 10}, 'end': {}}
```

&emsp;&emsp;定义creat_costs_table函数创建初始的costs表，这个表表示到节点的最短距离。
```python
def creat_costs_table(graph):
    costs = {}
    for i in graph.keys():
        if i=='start':
            continue
        elif i in graph['start'].keys():
            costs[i]=graph['start'][i]
        else:
            costs[i]=float('inf')
    return costs
{'A': 5, 'B': 0, 'C': inf, 'D': inf, 'end': inf}
```
&emsp;&emsp;定义creat_parents_table函数创建初始的parents表，表示节点的父节点，也就是实现最短路径的上一个节点。

```python
def creat_parents_table(graph):
    parents = {}
    for i in graph.keys():
        if i=='start':
            continue
        elif i in graph['start'].keys():
            parents[i]='start'
        else:
            parents[i]=None
    return parents
{'A': 'start', 'B': 'start', 'C': None, 'D': None, 'end': None}
```
&emsp;&emsp;通过上面的初始表看出，都是以start节点为基础，定义到了其子节点。接下来定义Dijkstra_algorithm算法函数：

```python
def Dijkstra_algorithm(graph,costs,parents):
    while(1):
        #当costs表中只剩下“end",则表示所有节点都处理完毕，可以退出
        if len(costs.keys())==1:
            break
        else:
            # 找到当前cost表里“最便宜”的节点
            node_now = list(costs.keys())[list(costs.values()).index(min(costs.values()))]
            # 对这个节点的所有子节点处理
            for z in graph[node_now].keys():
                #如果通过node_now到子节点z的距离相较于之前到达z距离更短
                if costs[z]>costs[node_now]+graph[node_now][z]:
                    #则更新到达z的最短距离
                    costs[z]=costs[node_now]+graph[node_now][z]
                    #同时更新z的父节点
                    parents[z] = node_now
            # 在costs表中删除这个点，表示已经处理过了
            del costs[node_now]
    road = ['end']
    node_now='end'
    #最后获取到达end的路径
    while(1):
        if node_now=='start':
            break
        road.insert(0,parents[node_now])
        node_now = parents[node_now]

    return costs,road
```
例如，一开始的costs和parents为：
```PYTHON
{'A': 5, 'B': 0, 'C': inf, 'D': inf, 'end': inf}
{'A': 'start', 'B': 'start', 'C': None, 'D': None, 'end': None}
```
当前路径最短的是B点，于是查看B的子节点，也就是C和D，C和D当前的距离都是INF，显然需要更新，例如从B到C的距离为0+30=30，那么C的当前最短距离为30，D同理，且完成后删除costs中的B，那么更新为：
```PYTHON
{'A': 5, 'C': 30, 'D': 35, 'end': inf}
{'A': 'start', 'B': 'start', 'C': 'B', 'D': 'B', 'end': None}
```
下一个是A点（当前的路径5是最短的），其子节点为C和D，从A到C点的距离为5+15<30，那么C点需要更新，同理，D也要更新：
```PYTHON
{'C': 20, 'D': 25, 'end': inf}
{'A': 'start', 'B': 'start', 'C': 'A', 'D': 'A', 'end': None}
```
然后是C，其子节点只有end：
```PYTHON
{ 'D': 25, 'end': 40}
{'A': 'start', 'B': 'start', 'C': 'A', 'D': 'A', 'end': 'C'}
```
最后是D，其子节点只有end，从D到end距离为25+10=35，显然小于之前的40，需要更新：
```PYTHON
{'end': 35}
{'A': 'start', 'B': 'start', 'C': 'A', 'D': 'A', 'end': 'D'}
```
至此完成更新，得到的结果为：
```python
costs = creat_costs_table(graph)
parents = creat_parents_table(graph)
mincost,road = Dijkstra_algorithm(graph,costs,parents)
{'end': 35}
['start', 'A', 'D', 'end']
```

# 动态规划
&emsp;&emsp;可以从**背包问题**查看动态规划的一般过程：即如果你有一个容量为6的背包，然后有一些货物，他们各自有容量花费cost和其带来的收益get，请问最大收益是多少呢？
```python

goods={
    'A':{'cost':3,'get':10},
    'B':{'cost':1,'get':3},
    'C':{'cost':2,'get':9},
    'D':{'cost':2,'get':5},
    'E':{'cost':1,'get':6}
}
my_capacity = 6
```
&emsp;&emsp;动态规划的解决都是从一个table开始的，代表了每一个子问题的最优解。这个table的行数往往是货物种类，列为**以货物最小花费为最小值，容量为最大值，货物最小花费步进的数列**
&emsp;&emsp;例如对于这个问题，最大容量是6，最小花费是B或者E的1，那么列就应该是[1,2,3,4,5,6].如果还有另外一个货物F，花费是0.5，则列应该是[0.5,1,1.5...6]
&emsp;&emsp;思想是最开始简化为只有一个货物的情况，然后慢慢增加货物，获取最优目标。当假设现在只有A货物的时候，最大收益随着背包容量的变化为：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/94812854e32cc080ab8d0e91aa1b6c9c.png)

&emsp;&emsp;即当我的容量是1和2时，无法放下A，所以此时的最大效益为0，当容量是3-6时，都能放下A，所以最大收益就是A的收益，也就是10.
&emsp;&emsp;再看第二行，现在我有A和B两个货物选择，当有1-2容量时，因为这种情况下不能放A，那么这里应该放一个B，收益为3。
&emsp;&emsp;当容量是3时，A和B都可以放，但是只能放一个，那么显然放A的收益更高，收益为10
&emsp;&emsp;当容量是4-6时，A和B可以同时放，收益为13
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a241ae9180c95152551121145120c6c5.png)

事实上，每个单元格都采用了公式：
<!-- $$ table[i][j]=max\left\{
\begin{matrix}
 上一个单元格的值，即table[i-1][j] \\
 当前商品的价值+剩余空间的价值（table[i-1][j-当前商品的花费]） 
\end{matrix}
\right.}
$$ -->

这里其实对应就在加入新的商品的两种选择：拿这个商品或者不拿，看看哪种情况收益更高。

```python
#获取货物的最小花费，然后得到table的行和列的数量
cost_list=[]
for i in goods.keys():
    cost_list.append(goods[i]['cost'])
min_cost = min(cost_list)
column_num = int(my_capacity/min_cost)
row_num = len(goods.keys())

for i in range(row_num):
    # 当前这一行对应物品、花费和利益
    good_current = list(goods.keys())[i]
    cost_now = goods[good_current]['cost']
    get_now = goods[good_current]['get']
    for j in range(column_num):
        # 对第一行只需要判断是否能放下当前的商品
        if i==0:
            if (j+1)*min_cost<cost_now:
                table[i,j] = 0
            else:
                table[i,j] = get_now
        else:
            # 如果当前的容量都不够放入当前的商品，则直接等于table[i-1][j]
            if (j+1)*min_cost-cost_now<0:
                table[i,j] =table[i-1,j]
            # 如果刚好能装下，则要比较table[i-1][j]和当前商品的价值
            elif (j+1)*min_cost-cost_now==0:
                table[i,j] = max(table[i - 1, j],get_now)
            # 如果装得下，且还有空间剩余，则用到了上面的公式
            # table[i - 1, j]代表当前不做任何处理，直接拿上次的结果
            # get_now +xxx表示这次要拿当前商品，xxx代表剩余空间的价值
            # 例如如果拿了当前商品之后还剩下x空间，就应该找到table[i-1][x]表示这x空间的最大价值
            else:
                table[i, j] = max(table[i - 1, j], (get_now + table[i - 1, int(((j+1)*min_cost - cost_now-min_cost)/min_cost)]))

 ```

 上述问题的结果为：
 ```python
  [[ 0.  0. 10. 10. 10. 10.]
 [ 3.  3. 10. 13. 13. 13.]
 [ 3.  9. 12. 13. 19. 22.]
 [ 3.  9. 12. 14. 19. 22.]
 [ 6.  9. 15. 18. 20. 25.]]
 ```
 当前只能得到最大收益，无法得知需要获取什么商品，可以改进一下，其实就是增加一个good_list表，存储每一步所拿的商品
 ```python
 
cost_list=[]
for i in goods.keys():
    cost_list.append(goods[i]['cost'])


min_cost = min(cost_list)
column_num = int(my_capacity/min_cost)
row_num = len(goods.keys())

table = np.zeros((row_num,column_num))
# 存储表格里的每个值对应的拿的所有商品
good_list = []
for i in range(row_num):
    good_list.append([0]*column_num)

for i in range(row_num):
    # 当前这一行对应物品的花费和利益
    good_current = list(goods.keys())[i]
    cost_now = goods[good_current]['cost']
    get_now = goods[good_current]['get']
    for j in range(column_num):

        if i==0:
            if (j+1)*min_cost<cost_now:
                table[i,j] = 0
                good_list[i][j]=[]
            else:
                table[i,j] = get_now
                good_list[i][j]=[good_current]
        else:
            if (j+1)*min_cost-cost_now<0:
                table[i,j] =table[i-1,j]
                good_list[i][j] = good_list[i-1][j]
            elif (j+1)*min_cost-cost_now==0:
                if table[i - 1, j]>=get_now:
                    table[i,j] = table[i - 1, j]
                    good_list[i][j] = good_list[i-1][j]
                else:
                    table[i,j] = get_now
                    good_list[i][j]=[good_current]
            else:
                if table[i - 1, j]>=(get_now + table[i - 1, int(((j+1)*min_cost - cost_now-min_cost)/min_cost)]):
                    table[i, j] = table[i - 1, j]
                    good_list[i][j] = good_list[i - 1][j]
                else:
                    table[i, j] = get_now + table[i - 1, int(((j+1)*min_cost - cost_now-min_cost)/min_cost)]
                    good_list[i][j] = [good_current]+good_list[i - 1][int(((j+1)*min_cost - cost_now-min_cost)/min_cost)]

 ```
 结果为:
 ```python
 [[[], [], ['A'], ['A'], ['A'], ['A']], [['B'], ['B'], ['A'], ['B', 
 'A'], ['B', 'A'], ['B', 'A']], [['B'], ['C'], ['C', 'B'], ['B', 
 'A'], ['C', 'A'], ['C', 'B', 'A']], [['B'], ['C'], ['C', 'B'], ['D', 
 'C'], ['C', 'A'], ['C', 'B', 'A']], [['E'], ['C'], ['E', 'C'], ['E', 
 'C', 'B'], ['E', 'D', 'C'], ['E', 'C', 'A']]]
 ```
 都只需要看最后一个，即拿商品E C A ,收益为25


# 回溯算法
 
